## Goal
Learn and practice architecting, designing, and implementing distributed systems at scale by building a complex, startup-grade product with a small team of experienced engineers (using AI agents where helpful).

## High-level Approach

1. **Design phase — learn, architect, and design the system**  
   - Requirements gathering and problem definition  
   - Capability decomposition, service boundaries, interfaces, and data models  
   - High-level architecture and system design (consistency models, replication, partitioning, scalability tradeoffs)  
   - Non-functional requirements planning and infrastructure planning

2. **Concurrently drill into implementation details**  
   - High-level system design topics (data flow, capability decomposition, consistency, replication, partitioning)  
   - Low-level implementation concerns (design patterns, data structures, algorithms, concurrency primitives, performance optimizations, tech-stack tradeoffs)

3. **Learn by building**  
   - Choose a problem complex enough to force real architectural tradeoffs  
   - Iterate through the SDLC: clarify requirements, design architecture, select a stack, build infrastructure and tooling, implement bounded contexts using domain-driven design, test, deploy, and operate

## Execution Steps (Concise)

1. **Gather requirements** — understand and document the problem and key requirements.
2. **Design** — Decompose capabilities; define service boundaries and interfaces.  
3. **Define architecture traits and non-functional requirements** — list the architecture traits the problem demands and capture non-functional requirements (e.g., scalability, reliability, maintainability, performance, security, observability, cost efficiency, etc.).  
4. **Select tech stack** — choose technologies aligned with the required architecture traits and non-functional requirements.  
5. **Run a full SDLC** — set up dev environment, CI/CD, infrastructure-as-code, testing, deployment, and operations.  
6. **Implement and iterate** — implement business logic across bounded contexts using domain-driven design, test, deploy, monitor, and iterate.
